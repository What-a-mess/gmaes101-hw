# 作业2记录

## 一些笔记

main里面的投影变换从作业1复制出来就好

要注意判断点是否在三角形内部需要用叉积而不是点积（点积判断是否同向），学过高数的话应该知道用求行列式的方法求叉积的模长

$$
\vec{a} \times \vec{b} = 
\left|
\begin{matrix}
\vec{i} & \vec{j} & \vec{k} \\
a_1 & a_2 & a_3 \\
b_1 & b_2 & b_3 \\
\end{matrix}
\right|
$$

由于这里两个向量$\vec{a}, \vec{b}$都是二维的，所以把第三维填0，因此行列式按第一行展开时，第一行只剩取$\vec{k}$的项，得到向量为$(a_1b_2 - a_2b_1)\vec{k}$，模长为系数。

tips：这里如果错用点积计算点是否在三角形内的话，bounding box够大（0~699，即框架中整个屏幕的大小）会得到两个三角形均顺时针旋转了90度（不知道绕哪个点转的，没去分析）（这个错我找了好久，一开始完全没想到判断点是否在内部会导致这种错误，挺有意思的）

## MSAA

关于MSAA的实现，我在cnblogs上看到了一个简单地在rasterize_triangle将一个像素分成4部分采样的实现，这个思路其实是不对的，原因如下所述。

函数rasterize_triangle是对一个三角形单独进行栅格化，也就是说在对传入的三角形进行栅格化的过程中是没有考虑到其他图形的。

![边界](./notes.asstes/%E8%BE%B9%E7%95%8C.png)（这张图是正确渲染的结果）

![错误渲染](./notes.asstes/%E9%94%99%E8%AF%AF%E6%B8%B2%E6%9F%93.png)（这是从别的博客毛来的错误渲染的结果）

栅格化的过程中，MSAA是在将在三角形内部的点与不在三角形内部的点的颜色进行平均的。而在不考虑其他三角形的情况下，不在三角形内部的点均会被视为黑色（颜色(0, 0, 0)）。**在两个三角形相接的地方，MSAA应该进行两个三角形颜色的平均，但是由于不考虑其他三角形，这里会与黑色进行平均**，导致的结果就是两个三角形相交的地方可能会出现黑边（如果是水平边或垂直边，可能恰好不需要与其他颜色进行平均，也就不会出现黑边的问题）。

为解决这个问题，我单独设置了一个color_buffer（不能是函数局部变量，不然就没用了），用来存储每个采样点的颜色，然后再进行平均，这样才能保证在平均时能够考虑到另一个三角形的颜色（但是这样空间复杂度挺高的，不知道有没有更好的办法）

还有就是注意insideTriangle的接口，注意是不要传入的是浮点，结果函数接收参数是整数，这样的话传入的浮点数会被转成整数。
